<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


  <meta name="google-site-verification" content="VvyjvVXcJQa0QklHipu6pwm2PJGnnchIqX7s5JbbT_0" />





  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="胡编一通，乱写一气" />



  <meta name="keywords" content="IIFE,JavaScript,翻译," />



  <link rel="alternate" href="/atom.xml" title="IIssNan's Notes" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?50c15455e37f70aea674ff4a663eef27";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <title> [译] 立即执行函数表达式（IIFE） // IIssNan's Notes </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">IIssNan's Notes</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            标签
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
<form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'xWSYW1jSW_PiEKgkes91','2.0.0');
</script>

    </div>
  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              [译] 立即执行函数表达式（IIFE）
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于 2013-08-15
        </span>

        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2013/javascript-iife/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2013/javascript-iife/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        <p>原文：<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/" target="_blank" rel="external">Immediately-Invoked Function Expression (IIFE)</a></p>
<p>作者：”Cowboy” Ben Alman</p>
<p>或许你没有注意到，我是一个对术语比较在意的人。所以，在听到许多次JavaScript「自执行匿名函数」（self-executing anonymous function）或者「自调用匿名函数」（self-invoked anonymouse function）这两个流行但令人误解的术语，我觉得得将我的想法写下来。</p>
<p>本文实际上除了提供详细关于这个模式的原理之外，还推荐了我们之后如何称呼这个模式。当然，你可以跳过关于这个推荐的内容，直接查看<a href="#iife">「立即执行函数表达式」</a>的例子，但是我建议你完整地阅读本文。</p>
<p>请注意，本文并非是那种「我就是正确的，而你是错误」的论调。我真诚的希望帮助人们了解潜在的复杂的概念，并且深感使用一致并且精确的术语是一种非常有效的促进人们相互理解的方法。</p>
<a id="more"></a>
<h2 id="那么，到底本文旨在何处？">那么，到底本文旨在何处？</h2><p>在JavaScript中，每一个函数被调用时都会创建一个执行上下文（execution context）。定义在函数内部的变量和函数都只能在这个执行上下文的内部访问到，所以函数提供了一种创建私有成员的便捷的方法。</p>
<pre><code><span class="comment">// makeCounter返回了另外一个内部函数。</span>
<span class="comment">// 而这个内部函数可以访问私有变量i，所以这个内部函数实际上拥有一个特权（访问内部私有变量）</span>
<span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span><span class="params">()</span> </span>{
    <span class="comment">// `i`变量仅在`makeCounter`函数内部有效</span>
    <span class="keyword">var</span> i = <span class="number">0</span>;

    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
        <span class="built_in">console</span>.log(++i);
    };
}

<span class="comment">// 注意，`counter` 和 `counter2` 拥有各自的`i`</span>
<span class="keyword">var</span> counter = makeCounter();
counter(); <span class="comment">// logs: 1</span>
counter(); <span class="comment">// logs: 2</span>

<span class="keyword">var</span> counter2 = makeCounter();
counter2(); <span class="comment">// logs: 1</span>
counter2(); <span class="comment">// logs: 2</span>

i; <span class="comment">// ReferenceError: i未定义（i仅在makeCounter中有效）</span>
</code></pre><p>[译注]：<a href="http://jsfiddle.net/cEhxD/" target="_blank" rel="external">JSFiddle例子链接</a></p>
<p>在很多情况下，不论<code>makeWhatever</code>函数返回的是什么样的值，你希望这个值在每次返回都是相同的，或者，你根本不需要函数返回一个值。</p>
<h3 id="问题的本质">问题的本质</h3><p>假若你定义了一个函数：<code>function foo () {}</code> 或者 <code>var foo = function () {}</code>，你都获得了一个函数的引用变量。可以在在这个变量使用括号操作符（parenthese）来调用函数，即：<code>foo()</code>。</p>
<pre><code><span class="comment">// 像底下定义的函数可以在函数名之后放置括号()，比如foo()来调用。</span>
<span class="comment">// 而foo仅仅是一个函数表达式`function(){ /* code */ }`的引用。</span>
<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ <span class="comment">/* code */</span>}

<span class="comment">// 那么是否可以在函数表达式之后直接使用()来调用？</span>
<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{ <span class="comment">/* code */</span> }(); <span class="comment">// SyntaxError: Unexpected token (</span>
</code></pre><p>上面代码执行后就会抛出一个错误（catch）。当脚本解释器在全局命名空间或者函数内部遇到关键字<code>function</code>的时候，默认地，解释器认为这是一个函数声明语句（<a href="https://developer.mozilla.org/en/JavaScript/Reference/Statements/function" target="_blank" rel="external">function declaraction</a>），而非函数表达式（<a href="https://developer.mozilla.org/en/JavaScript/Reference/Operators/Special/function" target="_blank" rel="external">function expression</a>）。如果没有明确地告知解释器<code>function(){}()</code>是一个函数表达式，解释器将认为这是一个函数声明，并且声明没有指定函数的名字。由于函数声明时必需为指定函数的名称，所以解释器抛出<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/SyntaxError" target="_blank" rel="external">语法错误</a>（SyntaxError）。</p>
<h3 id="题外话：函数，括号以及语法错误">题外话：函数，括号以及语法错误</h3><p>有趣的是，既然是由于缺乏函数名称而导致语法错误，那么只要指定一个函数名字不就通过了？解释器依然会抛出一个语法错误提示，但却是由于不同的原因。当括号放置在函数表达式后，此括号即为括号运算符，表示调用函数；然而当括号放置在语句之后意味着分离括号前面与括号中的内容，此时括号仅仅做为分组表示（即用于改变运算的优先关系）。</p>
<pre><code><span class="comment">// 照理说底下语句是有效。但解释器认为这依然是一个函数声明语句。</span>
<span class="comment">// 后面的括号是分组操作，由于括号中没有内容，所以解释器抛出异常。</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }(); <span class="comment">// SyntaxError: Unexpected token )</span>

<span class="comment">// 既然由于括号内没有内容导致异常，那么只要在括号内加入内容不就可以了...</span>
<span class="comment">// 但是函数依然没有执行</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }( <span class="number">1</span> );

<span class="comment">// 上面的语句等价与一个函数声明，紧接这一个与函数完全无关的表达式。</span>
<span class="comment">// 这是解释器所看到的：</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }

( <span class="number">1</span> );
</code></pre><p>你可以访问Dmitry A. Soshnikove对于此运算内容翔实的文章：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 5. Functions</a>。</p>
<p><a name="iife"></a></p>

<h3 id="立即执行函数表达式（IIFE）">立即执行函数表达式（IIFE）</h3><p>幸运的是，可以简单地修复上述的语法错误问题。被广为接受的修复方式是使用括号明确告诉解释器这个是一个函数表达式。因为在JavaScript中，<strong>括号无法包含语句</strong>。因此，当解释器遇到括号中的<code>function</code>关键字时，将认为这是一个函数表达式，而非函数声明。</p>
<pre><code><span class="comment">// 这两种写法都可以立即执行一个函数表达式，同时创建了一个私有作用域</span>
(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }()); <span class="comment">// Crockford 推荐这种写法</span>
(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> })(); <span class="comment">// 但是这种也一样有效</span>

<span class="comment">// 由于括号或者强迫操作符用于让解释器可正确区分函数表达式与函数声明，所以在解释器可以正确区分的地方，括号就可以省略</span>
<span class="comment">// 不过请查看下面的重要说明</span>
<span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="keyword">return</span> <span class="number">10</span>; }();
<span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }();
<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }();

<span class="comment">// 如果不在意函数的返回值或者不在意代码的可读性，使用一元操作符亦是有效的</span>
!<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }();
~<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }();
-<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }();
+<span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }();

<span class="comment">// 以下是另外一种形式（@kuvos提供）。</span>
<span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }
<span class="keyword">new</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>{ <span class="comment">/* code */</span> }() <span class="comment">// 括号仅在传参时需要</span>
</code></pre><h3 id="关于上述代码中括号的一个重要说明">关于上述代码中括号的一个重要说明</h3><p>虽然在上述那些括号可有可无（因为解释器可以正确地识别他们是函数表达式），但还是建议在赋值语句中带上括号，作为一种不成文的约定。</p>
<p>括号在这种情况下表示函数将会立即被执行，同时，执行结果返回的函数执行的结果而非函数本身。通过这个约定，碰到一个函数表达式时就没有必要滚动到函数表达式的末尾（函数可能非常长）去查看是否立即执行了这个函数。</p>
<p>根据以往的经验，编写清晰的代码在技术上可以避免JavaScript解释器抛语法错误异常，同时也可以避免遇到「屎一样的BUG」。</p>
<h3 id="使用闭包（closures）保存状态">使用闭包（closures）保存状态</h3><p>实参可以传递给函数名（通过函数声明），也可以传递给立即调用的函数表达式。同时，函数（outer）可以在内部定义另外一个函数（inner），此时内部函数（inner）可以访问外部函数(outer)的传递进来参数和变量（这种关系被称为「闭包」）。结合上述的两种特性，我们可以使用「立即执行函数表达式」来锁定变量值并保存状态。</p>
<p>如果想要了解更多关于「闭包」的内容，请访问：<a href="http://skilldrick.co.uk/2011/04/closures-explained-with-javascript/" target="_blank" rel="external">Closures explained with JavaScript</a>。</p>
<pre><code><span class="comment">// 底下例子不会按照你的预期工作，因为`i`的值没有被锁定。</span>
<span class="comment">// 相反，当任意一个链接被点击时（在循环结束之后），弹出的值中i的值都等于elems.length。</span>
<span class="comment">// 这是因为在链接被点击的时候（循环之后），`i`的值就是elems.length</span>
<span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);
<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) {
    elems[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{
        e.preventDefault();
        alert(<span class="string">'I am link #'</span> + i);
    }, <span class="string">'false'</span>);
}

<span class="comment">// 这个例子如预期工作，因为在IIFE内部，`i`的值被锁定为`lockedInIndex`。</span>
<span class="comment">// 即使在循环之后`i`的值为元素的总个数，但是在IIFE中，`lockedInIndex`的值永远都是IIFE被调用的时候传入的`i`的值。</span>
<span class="comment">// 也就是说循环时每次传入的`i`(0, 1...)都在IIFE调用是固定为`lockedInIndex`，不会被改变。</span>
<span class="comment">// 所以每个链接被点击时都获取到了期望的`i`值</span>
<span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);
<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) {
    (<span class="function"><span class="keyword">function</span> <span class="params">(lockedInIndex)</span> </span>{
        elems[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{
            e.preventDefault();
            alert(<span class="string">'I am link #'</span> + lockedInIndex);
        }, <span class="string">'false'</span>);
    })(i);
}

<span class="comment">// 也可以采用这种方式。在click的回掉函数上使用IIFE锁定`i`的值并返回一个函数。</span>
<span class="comment">// 两种方式都可以按照预期的想法工作。但是上面的例子更易阅读。</span>
<span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);
<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) {
    elems[i].addEventListener(<span class="string">'click'</span>, (<span class="function"><span class="keyword">function</span> <span class="params">(lockedInIndex)</span> </span>{
        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>{
            e.preventDefault();
            alert(<span class="string">'I am link #'</span> + lockedInIndex);
        };
    })(i), <span class="string">'false'</span>);
}
</code></pre><p>注意上述代码中的最后两个例子，<code>lockedInIndex</code>可以正确的使用<code>i</code>的值。使用<code>lockedInIndex</code>作为立即执行函数表达式的参数令代码看起来更易理解。</p>
<p>立即执行函数表达式的另外一个优点在于，由于立即执行函数表达式并未使用标识符来命名，即未命名或者匿名的，所以可以不污染全局命名空间的情况使用。</p>
<h3 id="那么术语「自执行匿名函数」哪里不对？">那么术语「自执行匿名函数」哪里不对？</h3><p>在上文中已经多次提到我所建议的术语「立即执行函数表达式」，或者简写为「IIFE」，但是并未明确说明。我将他念成「iffi」（亦非？）。</p>
<p>什么是「立即执行函数表达式」？顾名思义，她是一个被立即执行的函数表达式。</p>
<p>我很希望看到JavaScript社区接受「立即执行函数表达式」（IIFE），在他们的文章中使用这个术语。因为我觉得IIFE让这个概念更加清晰，也因为术语「自执行匿名函数」并不准确：</p>
<pre><code><span class="comment">// 这是一个「自执行函数」。函数在内部调用本身，形成递归。</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> { <span class="title">foo</span><span class="params">()</span>; }</span>

<span class="comment">// 这是一个「自执行匿名函数」。因为没有命名，所以在函数内部使用arguments.callee来调用自身。</span>
var foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> { <span class="title">arguments</span>.<span class="title">callee</span><span class="params">()</span>; };</span>

<span class="comment">// 这应该就是一个所谓的「自执行匿名函数」了，但仅限于`foo`标识符引用这个函数。</span>
<span class="comment">// 如果foo指向了其他的值，那么这个就成为了「曾经是自执行匿名函数」了。</span>
var foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> { <span class="title">foo</span><span class="params">()</span>; };</span>

<span class="comment">// 这个语句被称为「自执行匿名函数」。但是她并非自执行，因为她根本没有调用她本身。这是一个立即执行函数。</span>
(<span class="function"><span class="keyword">function</span><span class="params">()</span>{ /* <span class="title">code</span> */ }<span class="params">()</span>);</span>

<span class="comment">// 为一个函数表达式指定名字在调试的时候异常有由，在调用栈里可以查找到。</span>
<span class="comment">// 然后一旦指定名字，这就是一个非匿名函数了。</span>
(<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{ /* <span class="title">code</span> */ }<span class="params">()</span>);</span>

<span class="comment">// IIFE同样可以调用自身，但或许这不是一个非常有用的形式。</span>
(<span class="function"><span class="keyword">function</span><span class="params">()</span>{ <span class="title">arguments</span>.<span class="title">callee</span><span class="params">()</span>; }<span class="params">()</span>);</span>
(<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{ <span class="title">foo</span><span class="params">()</span>; }<span class="params">()</span>);</span>

<span class="comment">// 最后一提，以下这个语句在BlackBerry5中会异常，因为在一个具名函数内部，此变量引用的函数还未生成是undefined。有趣吧？</span>
(<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span>{ <span class="title">foo</span><span class="params">()</span>; }<span class="params">()</span>);</span>
</code></pre><p>希望上述的例子可以验证「自执行」这个词是令人误解的。虽然函数一样是执行了，但并非是函数执行她本身。同时，「匿名」也无须特别指出，因为一个<strong>立即执行函数表达式</strong>可以匿名也可以具有名字。最后，我比较喜欢「invoked」而非「executed」在于押韵，我想「IIFE」看起来念起来比「IEFE」顺。</p>
<p>这就是我的想法。</p>
<p>由于<code>arguments.callee</code>在ECMAScript 5 strict mode中已被弃用，所以从技术上说一个<em>自执行匿名函数</em>是不可能实现的。</p>
<h3 id="最后的题外话：模块模式（Module_Pattern）">最后的题外话：模块模式（Module Pattern）</h3><p>当我在论述函数表达式的时候，可以漏掉了模块模式。若你对JavaScript里面的模块模式不熟悉的话，那么查看文中第一个例子，那个例子就是接近于模块模式。之所以说接近，是由于模块模式返回的是一个对象，而第一个例子返回的是函数。若第一个例子返回值改成一个对象，也就通常实现单例模式（Singleton Pattern）的方法，如下代码所示：</p>
<pre><code><span class="comment">// 创建一个立即执行的匿名函数表达式，并将函数的返回值赋予一个变量。</span>
<span class="comment">// 与第一例子相比，这个方法略去了`makeWhatever`中间函数。</span>

<span class="comment">// 就像上面重要提示中所述，尽管在这个例子中，外面的括号是非必需的。</span>
<span class="comment">// 但加上括号可以明确这是以立即执行的函数，将函数的结果赋予变量，而非将函数赋予变量。</span>
<span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
    <span class="keyword">var</span> i = <span class="number">0</span>;

    <span class="keyword">return</span> {
        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">return</span> i;
        },
        <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span> <span class="params">(val)</span> </span>{
            i = val;
        },
        increment: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
            <span class="keyword">return</span> ++i;
        }
    };
}());

<span class="comment">// `counter`是一个带有成员的对象，在此例中她的成员都是函数。</span>

counter.<span class="keyword">get</span>(); <span class="comment">// 0</span>
counter.<span class="keyword">set</span>(<span class="number">3</span>);
counter.increment(); <span class="comment">// 4</span>
counter.increment(); <span class="comment">// 5</span>

counter.i; <span class="comment">// undefined (`i` 并非`counter`的成员)</span>
i; <span class="comment">// ReferenceError: i未定义 (仅存在于匿名函数表达式形成的私有作用域中，即闭包)</span>
</code></pre><p>[译注] <a href="http://jsfiddle.net/kDBdu/" target="_blank" rel="external">例子的JSFiddle链接</a></p>
<p>模块模式不仅仅强大并且简洁明了。使用很少的代码就可以有效地将方法和属性封装起来，与此同时不污染全局命名空间以及创建私有作用域。</p>
<h2 id="扩展阅读">扩展阅读</h2><p>希望本文可以解答你的一些疑虑。当然，若阅读完本文之后你的疑问比之前更多了，你可以阅读以下列表的文章以探索更多关于函数以及模块模式：</p>
<ul>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses" target="_blank" rel="external">ECMA-262-3 in detail. Chapter 5. Functions</a> - Dmitry A. Soshinikov</li>
<li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Functions_and_function_scope" target="_blank" rel="external">Functions and function scope</a> - Mozilla Developer Network</li>
<li><a href="http://kangax.github.com/nfe/" target="_blank" rel="external">Named function expressions</a> - Named function expressions - Juriy “kangax” Zaytsev</li>
<li><a href="http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth" target="_blank" rel="external">JavaScript Module Pattern: In-Depth</a> - JavaScript Module Pattern: In-Depth - Ben Cherry</li>
<li><a href="http://skilldrick.co.uk/2011/04/closures-explained-with-javascript/" target="_blank" rel="external">Closures explained with JavaScript</a> - Nick Morgan</li>
</ul>
<p>最后感谢 Asen Bozhilov 和 John David Dalton 的技术建议以及Nick Morgan的深刻见解。如果你由任何想法，请在评论里发表，谢谢！</p>

      
    </div>

    <div class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iife/"> #IIFE </a>
          
            <a href="/tags/javascript/"> #JavaScript </a>
          
            <a href="/tags/翻译/"> #翻译 </a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2013/sync-git-repos-in-cloud/">使用网盘（Dropbox/Google Drive）同步Git仓库</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2013/tdd-in-practice-javascript-string-duplicate/">测试驱动开发实践：JavaScript字符串的复制函数</a>
            
          </div>
        </div>
      

      
      
    </div>
  </div>



    
      <div class="comments" id="comments">
        
          <div class="ds-thread" data-thread-key="2013/javascript-iife/"
               data-title="[译] 立即执行函数表达式（IIFE）" data-url="http://notes.iissnan.com/2013/javascript-iife/">
          </div>
        
      </div>
    
  </div>


        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="https://avatars1.githubusercontent.com/u/32269?v=3&s=460" alt="IIssNan" />
          <p class="site-author-name">IIssNan</p>
        </div>
        <p class="site-description motion-element">胡编一通，乱写一气</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">178</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">4</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">109</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </div>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml">
              <i class="menu-item-icon icon-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
              <a href="https://github.com/iissnan" target="_blank">GitHub</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="https://twitter.com/iissnan" target="_blank">Twitter</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://weibo.com/iissnan" target="_blank">Weibo</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://douban.com/people/iissnan" target="_blank">DouBan</a>
            </span>
            
              <span class="links-of-author-item">
              <a href="http://www.zhihu.com/people/iissnan" target="_blank">ZhiHu</a>
            </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

      </div>

      
        <div class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#那么，到底本文旨在何处？"><span class="nav-number">1.</span> <span class="nav-text">那么，到底本文旨在何处？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题的本质"><span class="nav-number">1.1.</span> <span class="nav-text">问题的本质</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#题外话：函数，括号以及语法错误"><span class="nav-number">1.2.</span> <span class="nav-text">题外话：函数，括号以及语法错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#立即执行函数表达式（IIFE）"><span class="nav-number">1.3.</span> <span class="nav-text">立即执行函数表达式（IIFE）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于上述代码中括号的一个重要说明"><span class="nav-number">1.4.</span> <span class="nav-text">关于上述代码中括号的一个重要说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用闭包（closures）保存状态"><span class="nav-number">1.5.</span> <span class="nav-text">使用闭包（closures）保存状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那么术语「自执行匿名函数」哪里不对？"><span class="nav-number">1.6.</span> <span class="nav-text">那么术语「自执行匿名函数」哪里不对？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后的题外话：模块模式（Module_Pattern）"><span class="nav-number">1.7.</span> <span class="nav-text">最后的题外话：模块模式（Module Pattern）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展阅读"><span class="nav-number">2.</span> <span class="nav-text">扩展阅读</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </div>
      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp;  2011 - 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">IIssNan</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/mist.js"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.3" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var $sidebarInner = $('.sidebar-inner');
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.didShow', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;
          var self = this;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      $(indicator).velocity('stop').velocity({
        opacity: action === 'show' ? 0.4 : 0
      }, { duration: 100 });
    }

  });
</script>


  <script type="text/javascript" id="sidebar.nav">
    $(document).ready(function () {
      var html = $('html');

      $('.sidebar-nav li').on('click', function () {
        var item = $(this);
        var activeTabClassName = 'sidebar-nav-active';
        var activePanelClassName = 'sidebar-panel-active';
        if (item.hasClass(activeTabClassName)) {
          return;
        }

        var currentTarget = $('.' + activePanelClassName);
        var target = $('.' + item.data('target'));

        currentTarget.velocity('transition.slideUpOut', 200, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', 200)
            .addClass(activePanelClassName);
        });

        item.siblings().removeClass(activeTabClassName);
        item.addClass(activeTabClassName);
      });

      $('.post-toc a').on('click', function (e) {
        e.preventDefault();
        var offset = $(escapeSelector(this.getAttribute('href'))).offset().top;
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        });
      });

      // Expand sidebar on post detail page by default, when post has a toc.
      var $tocContent = $('.post-toc-content');
      if (isDesktop() && CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    });
  </script>




  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"notes-iissnan"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  


  
  

</body>
</html>
